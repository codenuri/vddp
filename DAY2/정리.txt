디자인 패턴 
=> 특정 문제를 해결하기 위해 사용된 전형적인 코딩 기법에 "이름"을 부여 한것
=> GOF's 책에서는 23개의 이름을 소개
=> 대부분의 객체지향 언어로 구현 가능한 일반적인 기법 사용 

IDioms
=> 각 언어의 문법적 특징을 고려한 디자인 기법
=> C++ IDioms, Java IDioms, C# IDioms
=> 구글 "C++ IDioms" 에서 1번째 링크



==============================================================================
디자인 패턴의 핵심 원리 #1. 변하지 않은 코드에서 변하는 코드는 분리하는 것

#1. 변하는 코드는 가상함수로 분리
=> 의도 : 파생 클래스를 만들어서 가상함수를 override 하라는 것
=> 예제 : 도형편집기 예제의 draw()/draw_imp()
=> template method


#2. 변하는 코드를 다른 클래스로 분리(정책 클래스)

정책 클래스가 지켜야 하는 규칙을 어떻게 약속하고, 
정책 클래스를 어떻게 교체 가능하게 할것 인가 ?

strategy : 함수 이름을 인터페이스로 약속하고, 인터페이스를 사용해서 교체 가능하게!
		   Edit/IValidator 예제
		   23개 디자인 패턴중 하나 
			e.set_validator(&v1);
			e.set_validator(&v2);  // 실행시간에 정책 교체도 가능

policy base design : 함수 이름을 문서화로 약속하고, template 인자를 통해서 교체 가능하게!
					C++ IDioms
					std::vector<int, debug_alloc<int>> 예제!!
									=> 실행시 메모리 할당 정책을 바꿀수는 없다
									=> 교체해야 할 필요도 없다.


						성능				실행시간 교체 가능 여부
strategy 			: 가상함수				교체 가능
					  느리다

policy base design 	: 인라인 치환가능		교체 안됨
					  빠르다.
//=======================================================
디자인 패턴의 핵심 원리 #2. 공통의 기반 클래스 만들기

Folder 는 File 을 포함하지만 Foler 자신도 포함할수 있다.
=> 재귀적인 포함 
=> Folder 과 File 은 공통의 기반 클래스가 필요 하다.

왜? 어떤 의도로 재귀적인 포함을 사용하는가 ?

composite : 재귀적 포함을 사용한 복합객체 만들기 ( tree 모양의 복합객체 )
decorator : 재귀적 포함을 사용해서 객체에 기능 추가.


디자인 패턴의 핵심 원리 #3. 간접층을 만들자 
